// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Os from "os";
import * as Utils from "./Utils.bs.js";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function newCpu(param) {
  return {
          x: 1,
          pw: 0,
          crt: "",
          cycle: 1
        };
}

function toInstructions(input) {
  return Js_array.map((function (tokens) {
                if (Caml_array.get(tokens, 0) === "noop") {
                  return /* Noop */0;
                }
                if (Caml_array.get(tokens, 0) === "addx") {
                  return /* Addx */{
                          _0: Belt_Option.getExn(Belt_Int.fromString(Caml_array.get(tokens, 1)))
                        };
                }
                throw {
                      RE_EXN_ID: Utils.WentSouth,
                      Error: new Error()
                    };
              }), Js_array.map((function (line) {
                    return Js_string.split(" ", line);
                  }), Js_array.filter((function (line) {
                        return line !== "";
                      }), Js_string.split(Os.EOL, input))));
}

function execute(ins, cpu) {
  if (ins) {
    return {
            x: cpu.x + ins._0 | 0,
            pw: cpu.pw,
            crt: cpu.crt,
            cycle: cpu.cycle
          };
  } else {
    return cpu;
  }
}

function updatePw(cpu) {
  var match = (cpu.cycle - 20 | 0) % 40;
  if (match !== 0) {
    return cpu;
  } else {
    return {
            x: cpu.x,
            pw: cpu.pw + Math.imul(cpu.cycle, cpu.x) | 0,
            crt: cpu.crt,
            cycle: cpu.cycle
          };
  }
}

function nextCycle(cpu) {
  return {
          x: cpu.x,
          pw: cpu.pw,
          crt: cpu.crt,
          cycle: cpu.cycle + 1 | 0
        };
}

function updateCrt(cpu) {
  var match = Math.abs((cpu.cycle - 1 | 0) % 40 - cpu.x | 0) <= 1;
  if (match) {
    return {
            x: cpu.x,
            pw: cpu.pw,
            crt: cpu.crt + "#",
            cycle: cpu.cycle
          };
  } else {
    return {
            x: cpu.x,
            pw: cpu.pw,
            crt: cpu.crt + ".",
            cycle: cpu.cycle
          };
  }
}

function part01(input) {
  return Js_array.reduce((function (cpu, ins) {
                if (ins) {
                  return nextCycle(execute(ins, updatePw(nextCycle(updatePw(cpu)))));
                } else {
                  return nextCycle(execute(ins, updatePw(cpu)));
                }
              }), {
              x: 1,
              pw: 0,
              crt: "",
              cycle: 1
            }, toInstructions(input)).pw;
}

function part02(input) {
  var match = Js_array.reduce((function (cpu, ins) {
          if (ins) {
            return nextCycle(execute(ins, updateCrt(nextCycle(updateCrt(cpu)))));
          } else {
            return nextCycle(execute(ins, updateCrt(cpu)));
          }
        }), {
        x: 1,
        pw: 0,
        crt: "",
        cycle: 1
      }, toInstructions(input));
  var crt = match.crt;
  return Js_array.joinWith("\n", Utils.mapRange(0, 5, (function (row) {
                    return Js_string.slice(Math.imul(row, 40), Math.imul(row + 1 | 0, 40), crt);
                  })));
}

export {
  newCpu ,
  toInstructions ,
  execute ,
  updatePw ,
  nextCycle ,
  updateCrt ,
  part01 ,
  part02 ,
}
/* os Not a pure module */
